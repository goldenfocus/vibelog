#!/usr/bin/env node

/**
 * Golden Focus AI Session Dashboard
 *
 * Shows all active AI sessions, their status, and detects issues.
 *
 * Usage:
 *   ./sesh             - Show active sessions
 *   ./sesh --watch     - Live refresh every 30s
 *   ./sesh --audit     - Show weekly audit
 *   ./sesh --clean     - Remove stale locks (asks confirmation)
 */

const fs = require('fs');
const path = require('path');

// Configuration
const LOCK_DIR = path.join(__dirname, '../coordination/active');
const ARCHIVE_DIR = path.join(__dirname, '../coordination/archive');
const STALE_THRESHOLD_MS = 20 * 60 * 1000; // 20 minutes

// Colors for terminal output
const colors = {
  reset: '\x1b[0m',
  bright: '\x1b[1m',
  dim: '\x1b[2m',

  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
  cyan: '\x1b[36m',
  white: '\x1b[37m',
};

function colorize(text, color) {
  return `${colors[color] || ''}${text}${colors.reset}`;
}

function readLockFiles() {
  if (!fs.existsSync(LOCK_DIR)) {
    return [];
  }

  const files = fs.readdirSync(LOCK_DIR)
    .filter(f => f.endsWith('.lock') && f !== 'EXAMPLE-DO-NOT-USE.lock');

  return files.map(file => {
    const filePath = path.join(LOCK_DIR, file);
    try {
      const content = fs.readFileSync(filePath, 'utf8');
      return JSON.parse(content);
    } catch (err) {
      console.error(`Error reading ${file}:`, err.message);
      return null;
    }
  }).filter(Boolean);
}

function formatDuration(ms) {
  const seconds = Math.floor(ms / 1000);
  const minutes = Math.floor(seconds / 60);
  const hours = Math.floor(minutes / 60);

  if (hours > 0) {
    return `${hours}h ${minutes % 60}m`;
  } else if (minutes > 0) {
    return `${minutes}m`;
  } else {
    return `${seconds}s`;
  }
}

function getHeartbeatAge(heartbeatStr) {
  const heartbeat = new Date(heartbeatStr);
  const now = new Date();
  return now - heartbeat;
}

function isStale(heartbeatStr) {
  return getHeartbeatAge(heartbeatStr) > STALE_THRESHOLD_MS;
}

function showActiveSessions() {
  const locks = readLockFiles();

  console.log('\n' + colorize('ü§ñ GOLDEN FOCUS AI SESSIONS', 'cyan'));
  console.log(colorize('‚ïê'.repeat(60), 'dim'));
  console.log(colorize(`Last Updated: ${new Date().toISOString()}`, 'dim'));
  console.log();

  if (locks.length === 0) {
    console.log(colorize('  No active sessions', 'dim'));
    console.log();
    return;
  }

  console.log(colorize(`üü¢ ACTIVE SESSIONS (${locks.length})`, 'green'));
  console.log();

  locks.forEach((lock, index) => {
    const heartbeatAge = getHeartbeatAge(lock.heartbeat_last);
    const sessionAge = getHeartbeatAge(lock.started_at);
    const stale = isStale(lock.heartbeat_last);

    // Status indicator
    let status = '';
    let statusColor = 'green';

    if (stale) {
      status = 'üü° STALE';
      statusColor = 'yellow';
    } else if (lock.status === 'claiming') {
      status = 'üîµ CLAIMING';
      statusColor = 'blue';
    } else if (lock.status === 'active') {
      status = 'üü¢ ACTIVE';
      statusColor = 'green';
    } else if (lock.status === 'completed') {
      status = '‚úÖ COMPLETED';
      statusColor = 'cyan';
    }

    console.log(colorize(`‚îå‚îÄ Session ${index + 1}: ${lock.session_name}`, 'bright'));
    console.log(`‚îÇ  ${colorize('Status:', 'dim')} ${colorize(status, statusColor)}`);
    console.log(`‚îÇ  ${colorize('AI Type:', 'dim')} ${lock.ai_type} (${lock.platform})`);
    console.log(`‚îÇ  ${colorize('Task:', 'dim')} ${lock.task_number} - ${lock.task}`);
    console.log(`‚îÇ  ${colorize('Files:', 'dim')} ${lock.claimed_files.join(', ')}`);
    console.log(`‚îÇ  ${colorize('Started:', 'dim')} ${formatDuration(sessionAge)} ago`);
    console.log(`‚îÇ  ${colorize('Progress:', 'dim')} ${lock.progress_percent}%`);
    console.log(`‚îÇ  ${colorize('Heartbeat:', 'dim')} ${formatDuration(heartbeatAge)} ago`);

    if (lock.notes && lock.notes !== 'None') {
      console.log(`‚îÇ  ${colorize('Notes:', 'dim')} ${lock.notes}`);
    }

    if (stale) {
      console.log(`‚îÇ  ${colorize('‚ö†Ô∏è  WARNING: Stale heartbeat! AI may have crashed.', 'yellow')}`);
    }

    console.log('‚îÇ');
    console.log(colorize('‚îî' + '‚îÄ'.repeat(58), 'dim'));
    console.log();
  });

  // Check for conflicts
  const fileMap = new Map();
  locks.forEach(lock => {
    lock.claimed_files.forEach(file => {
      if (!fileMap.has(file)) {
        fileMap.set(file, []);
      }
      fileMap.get(file).push(lock.session_name);
    });
  });

  const conflicts = Array.from(fileMap.entries()).filter(([_, sessions]) => sessions.length > 1);

  if (conflicts.length > 0) {
    console.log(colorize('‚ö†Ô∏è  FILE CONFLICTS DETECTED!', 'red'));
    console.log();
    conflicts.forEach(([file, sessions]) => {
      console.log(colorize(`  File: ${file}`, 'red'));
      console.log(colorize(`  Claimed by: ${sessions.join(', ')}`, 'red'));
      console.log();
    });
  }

  // Summary
  const staleCount = locks.filter(l => isStale(l.heartbeat_last)).length;
  const activeCount = locks.filter(l => !isStale(l.heartbeat_last)).length;

  console.log(colorize('üìä SUMMARY', 'cyan'));
  console.log(colorize('‚îÄ'.repeat(60), 'dim'));
  console.log(`  ${colorize('Total Sessions:', 'dim')} ${locks.length}`);
  console.log(`  ${colorize('Active:', 'dim')} ${colorize(activeCount, 'green')}`);
  if (staleCount > 0) {
    console.log(`  ${colorize('Stale:', 'dim')} ${colorize(staleCount, 'yellow')} (may have crashed)`);
  }
  if (conflicts.length > 0) {
    console.log(`  ${colorize('Conflicts:', 'dim')} ${colorize(conflicts.length, 'red')}`);
  } else {
    console.log(`  ${colorize('Conflicts:', 'dim')} ${colorize('None ‚úÖ', 'green')}`);
  }
  console.log();
}

function showWeeklyAudit() {
  console.log('\n' + colorize('üìä WEEKLY AUDIT', 'cyan'));
  console.log(colorize('‚ïê'.repeat(60), 'dim'));
  console.log();

  if (!fs.existsSync(ARCHIVE_DIR)) {
    console.log(colorize('  No archive data available', 'dim'));
    console.log();
    return;
  }

  // Get last 7 days of archives
  const today = new Date();
  const archives = [];

  for (let i = 0; i < 7; i++) {
    const date = new Date(today);
    date.setDate(date.getDate() - i);
    const dateStr = date.toISOString().split('T')[0];
    const archiveFile = path.join(ARCHIVE_DIR, `${dateStr}.md`);

    if (fs.existsSync(archiveFile)) {
      archives.push({
        date: dateStr,
        content: fs.readFileSync(archiveFile, 'utf8')
      });
    }
  }

  if (archives.length === 0) {
    console.log(colorize('  No completed sessions this week', 'dim'));
    console.log();
    return;
  }

  // Count completed sessions
  let totalSessions = 0;
  let totalMerged = 0;
  let totalEscalated = 0;

  archives.forEach(archive => {
    const sessionMatches = archive.content.match(/### Session:/g);
    const mergedMatches = archive.content.match(/‚úÖ Merged to main/g);
    const escalatedMatches = archive.content.match(/üö® Escalated/g);

    totalSessions += sessionMatches ? sessionMatches.length : 0;
    totalMerged += mergedMatches ? mergedMatches.length : 0;
    totalEscalated += escalatedMatches ? escalatedMatches.length : 0;
  });

  const successRate = totalSessions > 0 ? Math.round((totalMerged / totalSessions) * 100) : 0;

  console.log(colorize(`  Period: Last ${archives.length} days`, 'dim'));
  console.log();
  console.log(`  ${colorize('‚úÖ Completed:', 'green')} ${totalSessions} tasks`);
  console.log(`  ${colorize('‚úÖ Auto-Merged:', 'green')} ${totalMerged} tasks`);
  if (totalEscalated > 0) {
    console.log(`  ${colorize('üö® Escalated:', 'yellow')} ${totalEscalated} tasks`);
  }
  console.log(`  ${colorize('üìà Success Rate:', 'cyan')} ${successRate}%`);
  console.log();

  if (successRate < 70) {
    console.log(colorize('  ‚ö†Ô∏è  Success rate is low. Review escalated tasks.', 'yellow'));
    console.log();
  }
}

function cleanStaleLocks() {
  const locks = readLockFiles();
  const staleLocks = locks.filter(l => isStale(l.heartbeat_last));

  if (staleLocks.length === 0) {
    console.log(colorize('\n‚úÖ No stale locks to clean\n', 'green'));
    return;
  }

  console.log(colorize(`\n‚ö†Ô∏è  Found ${staleLocks.length} stale lock(s):\n`, 'yellow'));

  staleLocks.forEach((lock, index) => {
    const heartbeatAge = getHeartbeatAge(lock.heartbeat_last);
    console.log(`  ${index + 1}. ${lock.session_name}`);
    console.log(`     Task: ${lock.task}`);
    console.log(`     Last heartbeat: ${formatDuration(heartbeatAge)} ago`);
    console.log();
  });

  // Ask for confirmation (simplified, just show instruction)
  console.log(colorize('To remove stale locks, delete them manually from:', 'dim'));
  console.log(colorize(`  ${LOCK_DIR}`, 'cyan'));
  console.log();
  console.log(colorize('‚ö†Ô∏è  Only remove locks if you\'re sure the AI crashed!', 'yellow'));
  console.log();
}

function watchSessions() {
  console.clear();
  showActiveSessions();

  console.log(colorize('üëÅÔ∏è  Watching... (refresh every 30s, Ctrl+C to stop)', 'dim'));
  console.log();

  setInterval(() => {
    console.clear();
    showActiveSessions();
    console.log(colorize('üëÅÔ∏è  Watching... (refresh every 30s, Ctrl+C to stop)', 'dim'));
    console.log();
  }, 30000);
}

// Main
const args = process.argv.slice(2);
const command = args[0];

switch (command) {
  case '--watch':
    watchSessions();
    break;

  case '--audit':
    showWeeklyAudit();
    break;

  case '--clean':
    cleanStaleLocks();
    break;

  case '--help':
  case '-h':
    console.log('\n' + colorize('Golden Focus AI Session Dashboard', 'cyan'));
    console.log();
    console.log('Usage:');
    console.log('  ./sesh             Show active sessions');
    console.log('  ./sesh --watch     Live refresh every 30s');
    console.log('  ./sesh --audit     Show weekly audit');
    console.log('  ./sesh --clean     Show stale locks (for manual cleanup)');
    console.log('  ./sesh --help      Show this help');
    console.log();
    break;

  default:
    showActiveSessions();
    break;
}
