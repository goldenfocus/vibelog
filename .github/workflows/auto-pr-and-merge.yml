name: Auto PR and Merge

on:
  push:
    branches:
      - 'feature/**'
      - 'feat/**'
      - 'fix/**'
      - 'claude/**'

permissions:
  contents: write
  pull-requests: write

jobs:
  create-pr-and-merge:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check if PR already exists
        id: check-pr
        uses: actions/github-script@v7
        with:
          script: |
            const branch = context.ref.replace('refs/heads/', '');

            const prs = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              head: `${context.repo.owner}:${branch}`,
              state: 'open',
              base: 'main'
            });

            if (prs.data.length > 0) {
              console.log(`PR already exists: #${prs.data[0].number}`);
              core.setOutput('pr_exists', 'true');
              core.setOutput('pr_number', prs.data[0].number);
            } else {
              console.log('No PR exists yet');
              core.setOutput('pr_exists', 'false');
            }

      - name: Create Pull Request
        if: steps.check-pr.outputs.pr_exists == 'false'
        id: create-pr
        uses: actions/github-script@v7
        with:
          script: |
            const branch = context.ref.replace('refs/heads/', '');

            // Get commit messages for PR body
            const commits = await github.rest.repos.compareCommits({
              owner: context.repo.owner,
              repo: context.repo.repo,
              base: 'main',
              head: branch
            });

            // Generate PR title from branch name
            const titleFromBranch = branch
              .replace(/^(feature|feat|fix|claude)\//, '')
              .split('-')
              .map(word => word.charAt(0).toUpperCase() + word.slice(1))
              .join(' ');

            // Get the latest commit message for title
            const latestCommit = commits.data.commits[commits.data.commits.length - 1];
            const commitTitle = latestCommit.commit.message.split('\n')[0];

            // Use commit title if it starts with conventional commit, otherwise use branch-based title
            const prTitle = commitTitle.match(/^(feat|fix|refactor|chore|docs|style|test|perf):/)
              ? commitTitle
              : `feat: ${titleFromBranch}`;

            // Build PR body from commits
            const commitList = commits.data.commits
              .map(c => `- ${c.commit.message.split('\n')[0]} (${c.sha.substring(0, 7)})`)
              .join('\n');

            const prBodyParts = [
              '## Auto-generated PR from ' + branch,
              '',
              '### Changes',
              '',
              commitList,
              '',
              '---',
              '',
              'ü§ñ This PR was automatically created and will auto-merge after successful Vercel deployment.',
              '',
              'Generated with [Claude Code](https://claude.com/claude-code)'
            ];
            const prBody = prBodyParts.join('\n');

            const pr = await github.rest.pulls.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: prTitle,
              body: prBody,
              head: branch,
              base: 'main'
            });

            console.log(`Created PR #${pr.data.number}: ${prTitle}`);
            core.setOutput('pr_number', pr.data.number);

      - name: Wait for Vercel deployment
        run: |
          echo "Waiting 3 minutes for Vercel deployment to complete..."
          sleep 180

      - name: Check deployment status and merge
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = parseInt('${{ steps.check-pr.outputs.pr_number || steps.create-pr.outputs.pr_number }}');
            const branch = context.ref.replace('refs/heads/', '');

            // Get PR details
            const pr = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });

            const sha = pr.data.head.sha;

            // Check for Vercel deployment status
            const checks = await github.rest.checks.listForRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: sha
            });

            // Look for Vercel-related checks
            const vercelChecks = checks.data.check_runs.filter(c =>
              c.name.toLowerCase().includes('vercel') ||
              c.name.toLowerCase().includes('deploy') ||
              c.app?.name?.toLowerCase().includes('vercel')
            );

            // Check if all Vercel checks passed
            let deploySuccess = false;

            if (vercelChecks.length > 0) {
              deploySuccess = vercelChecks.every(c => c.conclusion === 'success');
              console.log(`Found ${vercelChecks.length} Vercel checks`);
              vercelChecks.forEach(c => {
                console.log(`  - ${c.name}: ${c.conclusion}`);
              });
            } else {
              // Fallback: check commit status
              const status = await github.rest.repos.getCombinedStatusForRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: sha
              });

              const deployStatus = status.data.statuses.find(s =>
                s.context.toLowerCase().includes('vercel') ||
                s.context.toLowerCase().includes('deploy')
              );

              if (deployStatus) {
                deploySuccess = deployStatus.state === 'success';
                console.log(`Deployment status: ${deployStatus.state}`);
              } else {
                console.log('No Vercel deployment status found, proceeding with merge');
                deploySuccess = true; // Assume success if no checks found
              }
            }

            if (deploySuccess && pr.data.state === 'open' && !pr.data.merged) {
              // Squash and merge
              await github.rest.pulls.merge({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber,
                merge_method: 'squash',
                commit_title: pr.data.title,
                commit_message: `${pr.data.body}\n\nAuto-merged after successful deployment`
              });

              console.log(`‚úÖ Squash merged PR #${prNumber}`);

              // Delete the branch
              try {
                await github.rest.git.deleteRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: `heads/${branch}`
                });
                console.log(`‚úÖ Deleted branch: ${branch}`);
              } catch (error) {
                console.log(`Branch ${branch} may already be deleted or protected`);
              }
            } else {
              if (!deploySuccess) {
                console.log('‚ùå Deployment did not succeed, skipping merge');
                core.setFailed('Deployment checks did not pass');
              } else if (pr.data.state !== 'open') {
                console.log(`PR is ${pr.data.state}, not open`);
              } else if (pr.data.merged) {
                console.log('PR is already merged');
              }
            }
