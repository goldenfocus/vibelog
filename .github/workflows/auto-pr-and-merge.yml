name: Auto PR and Merge

on:
  push:
    branches:
      - 'feature/**'
      - 'feat/**'
      - 'fix/**'
      - 'claude/**'

permissions:
  contents: write
  pull-requests: write

jobs:
  create-pr-and-merge:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Fetch main branch
        run: git fetch origin main:main

      - name: Check if PR already exists
        id: check-pr
        uses: actions/github-script@v7
        with:
          script: |
            const branch = context.ref.replace('refs/heads/', '');

            const prs = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              head: `${context.repo.owner}:${branch}`,
              state: 'open',
              base: 'main'
            });

            if (prs.data.length > 0) {
              console.log(`PR already exists: #${prs.data[0].number}`);
              core.setOutput('pr_exists', 'true');
              core.setOutput('pr_number', prs.data[0].number);
            } else {
              console.log('No PR exists yet');
              core.setOutput('pr_exists', 'false');
            }

      - name: Create Pull Request
        if: steps.check-pr.outputs.pr_exists == 'false'
        id: create-pr
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          BRANCH="${GITHUB_REF#refs/heads/}"

          # Get latest commit message
          COMMIT_MSG=$(git log -1 --pretty=%B)
          COMMIT_TITLE=$(echo "$COMMIT_MSG" | head -1)

          # Generate title from branch name
          TITLE_FROM_BRANCH=$(echo "$BRANCH" | sed 's/^feature\|feat\|fix\|claude\///' | sed 's/-/ /g' | awk '{for(i=1;i<=NF;i++) $i=toupper(substr($i,1,1)) tolower(substr($i,2))}1')

          # Use commit title if it's conventional, otherwise use branch name
          if echo "$COMMIT_TITLE" | grep -qE '^(feat|fix|refactor|chore|docs|style|test|perf):'; then
            PR_TITLE="$COMMIT_TITLE"
          else
            PR_TITLE="feat: $TITLE_FROM_BRANCH"
          fi

          # Get commit list for PR body (with fallback)
          COMMIT_LIST=$(git log main..HEAD --pretty=format:'- %s (%h)' 2>/dev/null || git log -1 --pretty=format:'- %s (%h)')

          # Create PR body
          PR_BODY=$(cat <<EOF
          ## Auto-generated PR from $BRANCH

          ### Changes

          $COMMIT_LIST

          ---

          ü§ñ This PR was automatically created and will auto-merge after successful Vercel deployment.

          Generated with [Claude Code](https://claude.com/claude-code)
          EOF
          )

          # Create PR using gh CLI
          PR_URL=$(gh pr create --title "$PR_TITLE" --body "$PR_BODY" --base main --head "$BRANCH")
          PR_NUMBER=$(echo "$PR_URL" | grep -oE '[0-9]+$')

          echo "Created PR #$PR_NUMBER: $PR_TITLE"
          echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT

      - name: Wait for Vercel deployment
        run: |
          echo "Waiting 3 minutes for Vercel deployment to complete..."
          sleep 180

      - name: Check deployment status and merge
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = parseInt('${{ steps.check-pr.outputs.pr_number || steps.create-pr.outputs.pr_number }}');
            const branch = context.ref.replace('refs/heads/', '');

            // Get PR details
            const pr = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });

            const sha = pr.data.head.sha;

            // Check for Vercel deployment status
            const checks = await github.rest.checks.listForRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: sha
            });

            // Look for Vercel-related checks
            const vercelChecks = checks.data.check_runs.filter(c =>
              c.name.toLowerCase().includes('vercel') ||
              c.name.toLowerCase().includes('deploy') ||
              c.app?.name?.toLowerCase().includes('vercel')
            );

            // Check if all Vercel checks passed
            let deploySuccess = false;

            if (vercelChecks.length > 0) {
              deploySuccess = vercelChecks.every(c => c.conclusion === 'success');
              console.log(`Found ${vercelChecks.length} Vercel checks`);
              vercelChecks.forEach(c => {
                console.log(`  - ${c.name}: ${c.conclusion}`);
              });
            } else {
              // Fallback: check commit status
              const status = await github.rest.repos.getCombinedStatusForRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: sha
              });

              const deployStatus = status.data.statuses.find(s =>
                s.context.toLowerCase().includes('vercel') ||
                s.context.toLowerCase().includes('deploy')
              );

              if (deployStatus) {
                deploySuccess = deployStatus.state === 'success';
                console.log(`Deployment status: ${deployStatus.state}`);
              } else {
                console.log('No Vercel deployment status found, proceeding with merge');
                deploySuccess = true; // Assume success if no checks found
              }
            }

            if (deploySuccess && pr.data.state === 'open' && !pr.data.merged) {
              // Squash and merge
              await github.rest.pulls.merge({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber,
                merge_method: 'squash',
                commit_title: pr.data.title,
                commit_message: `${pr.data.body}\n\nAuto-merged after successful deployment`
              });

              console.log(`‚úÖ Squash merged PR #${prNumber}`);

              // Delete the branch
              try {
                await github.rest.git.deleteRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: `heads/${branch}`
                });
                console.log(`‚úÖ Deleted branch: ${branch}`);
              } catch (error) {
                console.log(`Branch ${branch} may already be deleted or protected`);
              }
            } else {
              if (!deploySuccess) {
                console.log('‚ùå Deployment did not succeed, skipping merge');
                core.setFailed('Deployment checks did not pass');
              } else if (pr.data.state !== 'open') {
                console.log(`PR is ${pr.data.state}, not open`);
              } else if (pr.data.merged) {
                console.log('PR is already merged');
              }
            }
